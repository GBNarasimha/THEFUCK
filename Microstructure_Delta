//+------------------------------------------------------------------+
//|                                     Microstructure_Absorption.mq5|
//|                                  Generated by Gemini AI Model    |
//|                    "Order Flow Absorption & Delta Scalper"       |
//+------------------------------------------------------------------+
#property copyright "Gemini AI"
#property version   "1.00"
#property indicator_separate_window // Show Delta in separate window
#property indicator_buffers 5
#property indicator_plots   3

//--- Plot 1: Delta Histogram
#property indicator_label1  "Volume Delta"
#property indicator_type1   DRAW_HISTOGRAM
#property indicator_color1  clrSilver
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2

//--- Plot 2: Bullish Absorption (Arrows on Main Chart via buffers, visualized here for reference)
// Note: We will use Objects for main chart arrows to keep code clean, 
// but we store values here for EA access.
#property indicator_label2  "Bullish Absorption"
#property indicator_type2   DRAW_ARROW
#property indicator_color2  clrLime
#property indicator_width2  3

//--- Plot 3: Bearish Absorption
#property indicator_label3  "Bearish Absorption"
#property indicator_type3   DRAW_ARROW
#property indicator_color3  clrRed
#property indicator_width3  3

//--- Input Parameters
input int      InpLookBack    = 100;     // Bars to Calculate (Keep low for speed)
input double   InpFilter      = 0.0;     // Min Volume Threshold (0 = Auto)
input bool     InpShowArrows  = true;    // Draw Arrows on Main Chart

//--- Indicator Buffers
double BufferDelta[];
double BufferBuySignal[];
double BufferSellSignal[];
double BufferBuyVol[];  // Hidden
double BufferSellVol[]; // Hidden

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- Indicator buffer mapping
   SetIndexBuffer(0, BufferDelta, INDICATOR_DATA);
   SetIndexBuffer(1, BufferBuySignal, INDICATOR_DATA);
   SetIndexBuffer(2, BufferSellSignal, INDICATOR_DATA);
   SetIndexBuffer(3, BufferBuyVol, INDICATOR_CALCULATIONS);
   SetIndexBuffer(4, BufferSellVol, INDICATOR_CALCULATIONS);

   //--- Plot Settings
   PlotIndexSetInteger(1, PLOT_ARROW, 233); // Up Arrow
   PlotIndexSetInteger(2, PLOT_ARROW, 234); // Down Arrow
   
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, 0.0);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, 0.0);

   IndicatorSetString(INDICATOR_SHORTNAME, "AI Microstructure Absorption");
   
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Main Calculation                                                 |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
  {
   //--- Only calculate the last 'InpLookBack' bars to save CPU
   int start_index = rates_total - InpLookBack;
   if(start_index < 0) start_index = 0;
   
   //If we have calculated before, only do the last few bars
   if(prev_calculated > rates_total - 2) start_index = prev_calculated - 2;

   for(int i = start_index; i < rates_total; i++)
     {
      // 1. Reset
      BufferBuySignal[i] = 0.0;
      BufferSellSignal[i] = 0.0;
      
      // 2. Fetch Ticks for this specific bar
      MqlTick ticks[];
      datetime start_time = time[i];
      // End time is the next bar's time, or current time if it's the last bar
      datetime end_time = (i < rates_total - 1) ? time[i+1] : TimeCurrent();
      
      int total_ticks = CopyTicksRange(_Symbol, ticks, COPY_TICKS_ALL, start_time * 1000, end_time * 1000);
      
      double buy_vol = 0;
      double sell_vol = 0;
      
      // 3. Analyze Microstructure (Tick by Tick)
      if(total_ticks > 0)
        {
         for(int k = 0; k < total_ticks; k++)
           {
            double vol = (ticks[k].volume > 0) ? (double)ticks[k].volume : 1.0;
            
            // Logic: Determine Aggressor
            // If tick flags exist, use them. If not (common in Forex), use price change.
            bool is_buy = false;
            bool is_sell = false;

            if((ticks[k].flags & TICK_FLAG_BUY) == TICK_FLAG_BUY) is_buy = true;
            else if((ticks[k].flags & TICK_FLAG_SELL) == TICK_FLAG_SELL) is_sell = true;
            else
              {
               // Fallback for brokers without explicit buy/sell flags
               // If price moved UP or stayed same at Ask -> Buy
               if(k > 0)
                 {
                  if(ticks[k].bid > ticks[k-1].bid) is_buy = true;
                  else if(ticks[k].bid < ticks[k-1].bid) is_sell = true;
                 }
              }
            
            if(is_buy) buy_vol += vol;
            if(is_sell) sell_vol += vol;
           }
        }
      
      // 4. Calculate Delta
      double delta = buy_vol - sell_vol;
      BufferDelta[i] = delta;
      
      // Color the histogram based on polarity
      if(delta > 0) PlotIndexSetInteger(0, PLOT_LINE_COLOR, clrLimeGreen);
      else          PlotIndexSetInteger(0, PLOT_LINE_COLOR, clrRed);

      // 5. THE AI ABSORPTION LOGIC
      // We are looking for Divergence between Price Action and Order Flow
      
      bool is_bullish_candle = (close[i] > open[i]);
      bool is_bearish_candle = (close[i] < open[i]);
      
      // BULLISH ABSORPTION (Buy Signal)
      // Scenario: Candle is Green (Price went up), BUT Delta is Red (Sellers were aggressive).
      // Meaning: Limit Buy Orders absorbed the selling pressure.
      if(is_bullish_candle && delta < 0)
        {
         // Filter: Ensure the delta is significant enough (simple noise filter)
         if(MathAbs(delta) > InpFilter)
           {
             BufferBuySignal[i] = delta; // Signal value (for EA reading)
             if(InpShowArrows) DrawArrow(i, time[i], low[i], true);
           }
        }

      // BEARISH ABSORPTION (Sell Signal)
      // Scenario: Candle is Red (Price went down), BUT Delta is Green (Buyers were aggressive).
      // Meaning: Limit Sell Orders absorbed the buying pressure.
      if(is_bearish_candle && delta > 0)
        {
         if(MathAbs(delta) > InpFilter)
           {
             BufferSellSignal[i] = delta; 
             if(InpShowArrows) DrawArrow(i, time[i], high[i], false);
           }
        }
     }
     
   return(rates_total);
  }

//+------------------------------------------------------------------+
//| Helper to Draw Arrows on Main Chart                              |
//+------------------------------------------------------------------+
void DrawArrow(int index, datetime time, double price, bool isBuy)
  {
   string name = "Absorb_" + (isBuy ? "Buy_" : "Sell_") + TimeToString(time);
   if(ObjectFind(0, name) >= 0) return; // Already exists

   if(isBuy)
     {
      ObjectCreate(0, name, OBJ_ARROW_UP, 0, time, price - Point()*10);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clrLime);
      ObjectSetInteger(0, name, OBJPROP_WIDTH, 2);
     }
   else
     {
      ObjectCreate(0, name, OBJ_ARROW_DOWN, 0, time, price + Point()*10);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clrRed);
      ObjectSetInteger(0, name, OBJPROP_WIDTH, 2);
     }
  }
//+------------------------------------------------------------------+
