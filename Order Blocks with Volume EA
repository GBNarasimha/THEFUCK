//+------------------------------------------------------------------+
//|                                     Order Blocks with Volume.mq5 |
//|                             Copyright 2025, Quantum Conversion   |
//+------------------------------------------------------------------+
#property copyright "QuantumTradingSystems"
#property version   "1.02"
#property description "Order Blocks with Volume Analysis (Ultra Low Lag)"
#property indicator_chart_window
#property indicator_buffers 0
#property indicator_plots   0

//--- ENUMS
enum ENUM_VOL_METHOD {
   VOL_SIMPLE,    // Simple
   VOL_RELATIVE,  // Relative
   VOL_WEIGHTED   // Weighted
};

//--- INPUTS
input group "Order Blocks"
input int      InpLookback       = 3;           // Consolidation Lookback
input double   InpThreshold      = 0.5;         // Breakout Threshold %
input int      InpMaxBlocks      = 10;          // Maximum Order Blocks
input int      InpMaxHistory     = 2000;        // Max History Bars (Prevents Lag)

input group "Volume"
input ENUM_VOL_METHOD InpVolMethod = VOL_RELATIVE; // Volume Calculation Method
input int      InpVolLookback    = 20;          // Volume Lookback Period
input double   InpVolThreshold   = 1.2;         // Volume Threshold Multiplier

//--- COLORS
color BullColor = C'11,133,30';  // #0b851e
color BearColor = C'242,54,69';  // #f23645

//--- STRUCTURES
struct OrderBlock {
   string   name;       // Unique object name
   double   top;        // Top Price
   double   bottom;     // Bottom Price
   bool     isBull;     // Type
   datetime time;       // Creation Time
   bool     active;     // Is active?
};

//--- GLOBALS
OrderBlock bullBlocks[];
OrderBlock bearBlocks[];

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
{
   // Clean up any existing objects from this indicator to start fresh
   ObjectsDeleteAll(0, "OBVol_");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Custom indicator deinitialization function                       |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   ObjectsDeleteAll(0, "OBVol_");
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   // Safety check for not enough data
   if(rates_total < InpVolLookback + 5) return(0);

   // Arrays as series for easier indexing matching Pine Script logic
   ArraySetAsSeries(time, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   ArraySetAsSeries(close, true);
   ArraySetAsSeries(tick_volume, true);

   // --- OPTIMIZED LIMIT CALCULATION (ZERO LAG) ---
   int limit;

   if(prev_calculated == 0)
   {
      // FIRST RUN: Only go back InpMaxHistory bars. 
      // Do NOT process the whole chart (could be 100k bars).
      limit = InpMaxHistory; 
      
      // Ensure we don't go out of bounds
      if(limit > rates_total - (InpVolLookback + 5))
         limit = rates_total - (InpVolLookback + 5);
   }
   else
   {
      // LIVE UPDATE: Calculate delta
      limit = rates_total - prev_calculated;
      
      // Add small buffer to ensure we catch the just-closed bar
      if(limit < 1) limit = 1; 
   }

   // --- MAIN LOOP ---
   // Loop stops at i >= 1 (Closed bars only).
   // We skip index 0 to prevent flickering and heavy recalculation on live ticks.
   
   for(int i = limit; i >= 1; i--)
   {
      // 1. Check Mitigation (Delete invalid blocks based on price action)
      CheckMitigation(i, low[i], high[i]);
      
      // 2. Calculate Logic
      bool is_consol = IsConsolidation(i, InpLookback, high, low);
      bool bull_break, bear_break;
      IsBreakout(i, close, high, low, open, bull_break, bear_break);
      
      // Calculate Volume
      double vol_strength = GetVolumeStrength(i, tick_volume, InpVolLookback);

      // 3. Create New Order Blocks
      if(is_consol && vol_strength >= InpVolThreshold)
      {
         if(bull_break)
         {
            CreateBlock(true, i, time, high, low, vol_strength);
         }
         if(bear_break)
         {
            CreateBlock(false, i, time, high, low, vol_strength);
         }
      }
   }

   // Return rates_total to save state for next tick
   return(rates_total);
}

//+------------------------------------------------------------------+
//| LOGIC: Volume Strength                                           |
//+------------------------------------------------------------------+
double GetVolumeStrength(int i, const long &vol[], int len)
{
   if(InpVolMethod == VOL_SIMPLE)
   {
      return (double)vol[i]; 
   }
   else if(InpVolMethod == VOL_RELATIVE)
   {
      double sum = 0;
      for(int k=0; k<len; k++) sum += (double)vol[i+k];
      double avg = sum / len;
      if(avg == 0) return 0.0;
      return (double)vol[i] / avg;
   }
   else // Weighted
   {
      double w1 = 2.0;
      double w2 = 1.0;
      return ((double)vol[i] * w1 + (double)vol[i+1] * w2) / (w1 + w2);
   }
}

//+------------------------------------------------------------------+
//| LOGIC: Consolidation                                             |
//+------------------------------------------------------------------+
bool IsConsolidation(int i, int len, const double &high[], const double &low[])
{
   double max_h = -DBL_MAX;
   double min_h = DBL_MAX;
   double max_l = -DBL_MAX;
   double min_l = DBL_MAX;

   // Find range over lookback
   for(int k=0; k<len; k++)
   {
      if(high[i+k] > max_h) max_h = high[i+k];
      if(high[i+k] < min_h) min_h = high[i+k];
      
      if(low[i+k] > max_l) max_l = low[i+k];
      if(low[i+k] < min_l) min_l = low[i+k];
   }
   
   double high_range = max_h - min_h;
   double low_range = max_l - min_l;
   double avg_range = (high_range + low_range) / 2.0;
   
   double current_range = high[i+1] - low[i+1];
   
   if(avg_range == 0) return false;
   
   return (current_range <= avg_range * (1.0 + InpThreshold));
}

//+------------------------------------------------------------------+
//| LOGIC: Breakout                                                  |
//+------------------------------------------------------------------+
void IsBreakout(int i, const double &close[], const double &high[], const double &low[], const double &open[], bool &bull, bool &bear)
{
   bull = (close[i] > high[i+2] && close[i] > open[i]);
   bear = (close[i] < low[i+2] && close[i] < open[i]);
}

//+------------------------------------------------------------------+
//| OBJECT: Create Block (OPTIMIZED FOR PERFORMANCE)                 |
//+------------------------------------------------------------------+
void CreateBlock(bool isBull, int i, const datetime &time[], const double &high[], const double &low[], double vol)
{
   string name_base = "OBVol_" + TimeToString(time[i]) + (isBull ? "_Bull" : "_Bear");
   string name_rect = name_base + "_Rect";
   string name_text = name_base + "_Txt";
   
   // --- Logic to manage Max Blocks (FIFO) ---
   if(isBull) 
   {
      ManageArraySize(bullBlocks);
   }
   else 
   {
      ManageArraySize(bearBlocks);
   }
   
   datetime t1 = time[i+1];
   double p_top = high[i+1];
   double p_bot = low[i+1];
   
   // --- CRITICAL OPTIMIZATION ---
   // Only set Object properties IF the object was just created.
   // Repeatedly calling ObjectSetInteger on existing objects causes massive lag.
   
   if(ObjectCreate(0, name_rect, OBJ_RECTANGLE, 0, t1, p_top, time[i], p_bot))
   {
      color c = isBull ? BullColor : BearColor;
      // These calls are EXPENSIVE. Only do them once per object.
      ObjectSetInteger(0, name_rect, OBJPROP_COLOR, c);
      ObjectSetInteger(0, name_rect, OBJPROP_FILL, true);
      ObjectSetInteger(0, name_rect, OBJPROP_BACK, true); 
      ObjectSetInteger(0, name_rect, OBJPROP_RAY_RIGHT, true);
      ObjectSetInteger(0, name_rect, OBJPROP_WIDTH, 0); 
   }
   
   if(ObjectCreate(0, name_text, OBJ_TEXT, 0, t1, isBull ? p_bot : p_top))
   {
      string txt = "Vol: " + DoubleToString(vol, 2) + "x";
      ObjectSetString(0, name_text, OBJPROP_TEXT, txt);
      ObjectSetInteger(0, name_text, OBJPROP_COLOR, isBull ? BullColor : BearColor);
      ObjectSetInteger(0, name_text, OBJPROP_FONTSIZE, 8);
      ObjectSetInteger(0, name_text, OBJPROP_ANCHOR, isBull ? ANCHOR_LEFT_UPPER : ANCHOR_LEFT_LOWER);
   }

   // Add to Array
   OrderBlock newBlock;
   newBlock.name = name_base;
   newBlock.top = p_top;
   newBlock.bottom = p_bot;
   newBlock.isBull = isBull;
   newBlock.time = t1;
   newBlock.active = true;
   
   if(isBull) 
   {
      ArrayResize(bullBlocks, ArraySize(bullBlocks)+1);
      bullBlocks[ArraySize(bullBlocks)-1] = newBlock;
   }
   else 
   {
      ArrayResize(bearBlocks, ArraySize(bearBlocks)+1);
      bearBlocks[ArraySize(bearBlocks)-1] = newBlock; 
   }
}

//+------------------------------------------------------------------+
//| LOGIC: Mitigation and Cleanup                                    |
//+------------------------------------------------------------------+
void CheckMitigation(int i, double currentLow, double currentHigh)
{
   // Check Bull Blocks
   for(int k = ArraySize(bullBlocks) - 1; k >= 0; k--)
   {
      if(bullBlocks[k].active)
      {
         // If price closes/wicks below the block
         if(currentLow <= bullBlocks[k].bottom)
         {
            ObjectDelete(0, bullBlocks[k].name + "_Rect");
            ObjectDelete(0, bullBlocks[k].name + "_Txt");
            ArrayRemove(bullBlocks, k, 1);
         }
      }
   }
   
   // Check Bear Blocks
   for(int k = ArraySize(bearBlocks) - 1; k >= 0; k--)
   {
      if(bearBlocks[k].active)
      {
         if(currentHigh >= bearBlocks[k].top)
         {
            ObjectDelete(0, bearBlocks[k].name + "_Rect");
            ObjectDelete(0, bearBlocks[k].name + "_Txt");
            ArrayRemove(bearBlocks, k, 1);
         }
      }
   }
}

void ManageArraySize(OrderBlock &arr[])
{
   if(ArraySize(arr) >= InpMaxBlocks)
   {
      // Delete oldest (FIFO)
      ObjectDelete(0, arr[0].name + "_Rect");
      ObjectDelete(0, arr[0].name + "_Txt");
      ArrayRemove(arr, 0, 1);
   }
}
