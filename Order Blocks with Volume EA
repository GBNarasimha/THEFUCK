//+------------------------------------------------------------------+
//|                                              OrderBlocksEA.mq5   |
//|                             , Narasi Conversion   |
//+------------------------------------------------------------------+
#property copyright "QuantumTradingSystems"
#property version   "1.01"
#property description "Order Blocks with Volume EA - Auto Close & Reverse Logic"

//--- INCLUDES
#include <Trade\Trade.mqh>

//--- ENUMS
enum ENUM_VOL_METHOD {
   VOL_SIMPLE,    // Simple
   VOL_RELATIVE,  // Relative
   VOL_WEIGHTED   // Weighted
};

//--- INPUTS
input group "Trading Settings"
input double   InpLotSize        = 0.1;         // Fixed Lot Size
input double   InpRiskReward     = 2.0;         // Risk:Reward Ratio (e.g. 1:2)
input int      InpMagicNum       = 123456;      // Magic Number
input int      InpSlippage       = 3;           // Max Slippage (points)

input group "Order Blocks"
input int      InpLookback       = 3;           // Consolidation Lookback
input double   InpThreshold      = 0.5;         // Breakout Threshold %
input int      InpMaxBlocks      = 10;          // Max Visual Blocks to Keep

input group "Volume"
input ENUM_VOL_METHOD InpVolMethod = VOL_RELATIVE; // Volume Calculation Method
input int      InpVolLookback    = 20;          // Volume Lookback Period
input double   InpVolThreshold   = 1.2;         // Volume Threshold Multiplier

//--- COLORS (Visuals)
color BullColor = C'11,133,30';  // #0b851e
color BearColor = C'242,54,69';  // #f23645

//--- STRUCTURES
struct OrderBlock {
   string   name;
   double   top;
   double   bottom;
   bool     isBull;
   datetime time;
   bool     active;
};

//--- GLOBALS
CTrade         trade;
OrderBlock     bullBlocks[];
OrderBlock     bearBlocks[];
datetime       lastBarTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(InpMagicNum);
   trade.SetDeviationInPoints(InpSlippage);
   
   // Clean up old visual objects
   ObjectsDeleteAll(0, "OBVol_");
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   ObjectsDeleteAll(0, "OBVol_");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // --- 1. NEW BAR CHECK ---
   datetime currentTime = iTime(_Symbol, _Period, 0);
   if(currentTime == lastBarTime) return; // Still on same bar
   lastBarTime = currentTime;

   // --- 2. DATA PREPARATION ---
   int dataNeeded = InpVolLookback + 10;
   
   double high[], low[], close[], open[];
   long   tick_volume[];
   datetime time[];

   if(CopyHigh(_Symbol, _Period, 0, dataNeeded, high) < dataNeeded) return;
   if(CopyLow(_Symbol, _Period, 0, dataNeeded, low) < dataNeeded) return;
   if(CopyClose(_Symbol, _Period, 0, dataNeeded, close) < dataNeeded) return;
   if(CopyOpen(_Symbol, _Period, 0, dataNeeded, open) < dataNeeded) return;
   if(CopyTickVolume(_Symbol, _Period, 0, dataNeeded, tick_volume) < dataNeeded) return;
   if(CopyTime(_Symbol, _Period, 0, dataNeeded, time) < dataNeeded) return;

   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   ArraySetAsSeries(close, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(tick_volume, true);
   ArraySetAsSeries(time, true);

   // --- 3. CALCULATE LOGIC ON LAST CLOSED BAR (Index 1) ---
   int i = 1; 

   // Maintenance
   CheckMitigation(low[i], high[i]);

   // Signal Logic
   bool is_consol = IsConsolidation(i, InpLookback, high, low);
   bool bull_break, bear_break;
   IsBreakout(i, close, high, low, open, bull_break, bear_break);
   double vol_strength = GetVolumeStrength(i, tick_volume, InpVolLookback);

   // --- 4. TRADING EXECUTION (REVERSAL LOGIC) ---
   if(is_consol && vol_strength >= InpVolThreshold)
   {
      // --- BULLISH SIGNAL ---
      if(bull_break)
      {
         // A. Close any existing Sell positions (Reversal)
         ClosePositions(POSITION_TYPE_SELL);
         
         // B. Only Buy if we don't already have a Buy (Once Buy)
         if(!HasOpenPosition(POSITION_TYPE_BUY))
         {
             CreateBlock(true, i, time, high, low, vol_strength); // Draw
             
             double sl = low[i+1]; 
             double entry = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
             double risk = entry - sl;
             
             if(risk > 0)
             {
                 double tp = entry + (risk * InpRiskReward);
                 sl = NormalizeDouble(sl, _Digits);
                 tp = NormalizeDouble(tp, _Digits);
                 
                 if(trade.Buy(InpLotSize, _Symbol, entry, sl, tp, "OB Bull Reversal"))
                 {
                     Print("Bullish Reversal: Sells closed, Buy opened.");
                 }
             }
         }
      }
      
      // --- BEARISH SIGNAL ---
      if(bear_break)
      {
         // A. Close any existing Buy positions (Reversal)
         ClosePositions(POSITION_TYPE_BUY);
         
         // B. Only Sell if we don't already have a Sell (Once Sell)
         if(!HasOpenPosition(POSITION_TYPE_SELL))
         {
             CreateBlock(false, i, time, high, low, vol_strength); // Draw
             
             double sl = high[i+1];
             double entry = SymbolInfoDouble(_Symbol, SYMBOL_BID);
             double risk = sl - entry;
             
             if(risk > 0)
             {
                 double tp = entry - (risk * InpRiskReward);
                 sl = NormalizeDouble(sl, _Digits);
                 tp = NormalizeDouble(tp, _Digits);
                 
                 if(trade.Sell(InpLotSize, _Symbol, entry, sl, tp, "OB Bear Reversal"))
                 {
                     Print("Bearish Reversal: Buys closed, Sell opened.");
                 }
             }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| HELPER: Close specific position types                            |
//+------------------------------------------------------------------+
void ClosePositions(ENUM_POSITION_TYPE type)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNum && PositionGetSymbol(ticket) == _Symbol)
         {
            if(PositionGetInteger(POSITION_TYPE) == type)
            {
               trade.PositionClose(ticket);
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| HELPER: Check if position exists                                 |
//+------------------------------------------------------------------+
bool HasOpenPosition(ENUM_POSITION_TYPE type)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNum && PositionGetSymbol(ticket) == _Symbol)
         {
            if(PositionGetInteger(POSITION_TYPE) == type) return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| LOGIC: Volume Strength                                           |
//+------------------------------------------------------------------+
double GetVolumeStrength(int i, const long &vol[], int len)
{
   if(InpVolMethod == VOL_SIMPLE) return (double)vol[i]; 
   else if(InpVolMethod == VOL_RELATIVE)
   {
      double sum = 0;
      for(int k=0; k<len; k++) sum += (double)vol[i+k];
      double avg = sum / len;
      return (avg == 0) ? 0.0 : (double)vol[i] / avg;
   }
   else // Weighted
   {
      return ((double)vol[i] * 2.0 + (double)vol[i+1] * 1.0) / 3.0;
   }
}

//+------------------------------------------------------------------+
//| LOGIC: Consolidation                                             |
//+------------------------------------------------------------------+
bool IsConsolidation(int i, int len, const double &high[], const double &low[])
{
   double max_h = -DBL_MAX, min_h = DBL_MAX, max_l = -DBL_MAX, min_l = DBL_MAX;

   for(int k=0; k<len; k++)
   {
      if(high[i+k] > max_h) max_h = high[i+k];
      if(high[i+k] < min_h) min_h = high[i+k];
      if(low[i+k] > max_l) max_l = low[i+k];
      if(low[i+k] < min_l) min_l = low[i+k];
   }
   
   double avg_range = ((max_h - min_h) + (max_l - min_l)) / 2.0;
   if(avg_range == 0) return false;
   
   return ((high[i+1] - low[i+1]) <= avg_range * (1.0 + InpThreshold));
}

//+------------------------------------------------------------------+
//| LOGIC: Breakout                                                  |
//+------------------------------------------------------------------+
void IsBreakout(int i, const double &close[], const double &high[], const double &low[], const double &open[], bool &bull, bool &bear)
{
   bull = (close[i] > high[i+2] && close[i] > open[i]);
   bear = (close[i] < low[i+2] && close[i] < open[i]);
}

//+------------------------------------------------------------------+
//| OBJECT: Create Block                                             |
//+------------------------------------------------------------------+
void CreateBlock(bool isBull, int i, const datetime &time[], const double &high[], const double &low[], double vol)
{
   string name_base = "OBVol_" + TimeToString(time[i]) + (isBull ? "_Bull" : "_Bear");
   string name_rect = name_base + "_Rect";
   string name_text = name_base + "_Txt";
   
   if(isBull) ManageArraySize(bullBlocks);
   else       ManageArraySize(bearBlocks);
   
   datetime t1 = time[i+1];
   double p_top = high[i+1];
   double p_bot = low[i+1];
   
   if(ObjectCreate(0, name_rect, OBJ_RECTANGLE, 0, t1, p_top, time[i], p_bot))
   {
      color c = isBull ? BullColor : BearColor;
      ObjectSetInteger(0, name_rect, OBJPROP_COLOR, c);
      ObjectSetInteger(0, name_rect, OBJPROP_FILL, true);
      ObjectSetInteger(0, name_rect, OBJPROP_BACK, true); 
      ObjectSetInteger(0, name_rect, OBJPROP_RAY_RIGHT, true);
      ObjectSetInteger(0, name_rect, OBJPROP_WIDTH, 0); 
   }
   
   if(ObjectCreate(0, name_text, OBJ_TEXT, 0, t1, isBull ? p_bot : p_top))
   {
      string txt = "Vol: " + DoubleToString(vol, 2) + "x";
      ObjectSetString(0, name_text, OBJPROP_TEXT, txt);
      ObjectSetInteger(0, name_text, OBJPROP_COLOR, isBull ? BullColor : BearColor);
      ObjectSetInteger(0, name_text, OBJPROP_FONTSIZE, 8);
      ObjectSetInteger(0, name_text, OBJPROP_ANCHOR, isBull ? ANCHOR_LEFT_UPPER : ANCHOR_LEFT_LOWER);
   }

   OrderBlock newBlock;
   newBlock.name = name_base;
   newBlock.top = p_top;
   newBlock.bottom = p_bot;
   newBlock.isBull = isBull;
   newBlock.time = t1;
   newBlock.active = true;
   
   if(isBull) 
   {
      ArrayResize(bullBlocks, ArraySize(bullBlocks)+1);
      bullBlocks[ArraySize(bullBlocks)-1] = newBlock;
   }
   else 
   {
      ArrayResize(bearBlocks, ArraySize(bearBlocks)+1);
      bearBlocks[ArraySize(bearBlocks)-1] = newBlock; 
   }
}

//+------------------------------------------------------------------+
//| LOGIC: Visual Maintenance                                        |
//+------------------------------------------------------------------+
void CheckMitigation(double currentLow, double currentHigh)
{
   for(int k = ArraySize(bullBlocks) - 1; k >= 0; k--)
   {
      if(bullBlocks[k].active && currentLow <= bullBlocks[k].bottom)
      {
         ObjectDelete(0, bullBlocks[k].name + "_Rect");
         ObjectDelete(0, bullBlocks[k].name + "_Txt");
         ArrayRemove(bullBlocks, k, 1);
      }
   }
   for(int k = ArraySize(bearBlocks) - 1; k >= 0; k--)
   {
      if(bearBlocks[k].active && currentHigh >= bearBlocks[k].top)
      {
         ObjectDelete(0, bearBlocks[k].name + "_Rect");
         ObjectDelete(0, bearBlocks[k].name + "_Txt");
         ArrayRemove(bearBlocks, k, 1);
      }
   }
}

void ManageArraySize(OrderBlock &arr[])
{
   if(ArraySize(arr) >= InpMaxBlocks)
   {
      ObjectDelete(0, arr[0].name + "_Rect");
      ObjectDelete(0, arr[0].name + "_Txt");
      ArrayRemove(arr, 0, 1);
   }
}
